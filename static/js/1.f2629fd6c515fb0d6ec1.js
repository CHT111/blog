webpackJsonp([1],{jP0Z:function(n,t,e){"use strict";function s(n){return{title:"闭包",time:"2018-12-25",comtent:"<BT2>1. 概述</BT2>\n        <DL>vuex是vue的状态管理工具，将所有的数据集中在一起管理,它分为以下四个部分:</DL>\n        <BT3>1.1 state</BT3>\n        <DL>state是vuex的状态集合，所有的状态都存在这个集合内,他是一个对象集合，如下：</DL>"+n('```\nstate:{\n  num:0,\n  one:"this is one",\n  two:"this is two"\n}```')+"\n            <DL>以上代码就是一个简单的状态集合，管理着全局的num、one、two. 所有关于这三个变量的获取、修改，都要通过vuex来改变。</DL>\n            <BT4>1.1.1 获取状态</BT4>\n            <DL>Vue可以将vuex通过根组件注入到每一个子组件中，并且在子组件中可以直接使用<eng>this.$store.state</eng>来访问状态：</DL>\n      \n            "+n("```\ncomputed: {\n  count () {\n    return this.$store.state.two\n  }\n}```")+"\n            <DL>通过计算属性绑定以后，当<eng>two</eng>发生变化时，会及时反馈在count上边，实现动态更新。</DL>\n            <BT3>1.2 getters</BT3>\n            <DL>getters一般用于获取state的派生状态，比如存一个数字num，获取的时候要获取num²，这样在每个组件获取后再分别处理会比较麻烦，此时可以用<eng>getters</eng>处理完毕以后直接获取num²：</DL>\n            "+n("```\ngetters: {\n  getOne: (state) => state.one\n}```")+"<DL>在组件中使用的方法类似<eng>state</eng>:</DL>\n            "+n('```\ncomputed: {\n  count () {\n    return this.$store.getters.getOne + "dede"\n  }\n}```')+"\n            <DL>此时count也会跟随state的状态变化而变化，实现动态改变。</DL>\n            <BT3>1.3 mutations</BT3>\n            <DL>改变state状态的唯一方法就是提交mutications（vue官网）。即不能直接调用mutitions的函数，应该通过<eng>this.$store.commit( 'SET_ONE' ,1000)</eng>。一个mutions的结构如下：</DL>"+n("```\nmutations: {\n  SET_ONE(state, n) {\n    state.one = n;\n  }\n}```")+"<DL>mutitions接收的第一个参数就是<eng>state</eng>。</DL>\n            <BT4>1.3.1 对象的提交方式</BT4>\n            <DL>mutitions的第二种提交方法:对象方式：<eng>this.$store.commit({ type : 'SET_ONE' , n : 121222121 })</eng>。\n            </DL>\n            <BT3>1.4 actions</BT3>\n            <DL>actions提交的的是mutitions。如下：</DL>\n            "+n('```\nactions: {\n  setTwo(context, n) {\n    context.commit("SET_TWO", n)\n  }\n}```')+"<DL>context是一个与store有相同的方法和属性的对象，可以直接调用<eng>context.commit( 'SET_ONE' )</eng>来提交mutitions。在实践中，我们可以利用参数解构来简化代码：</DL>"+n('```\nactions: {\n  setOne({commit}, n) {\n    commit("SET_ONE", n)\n  }\n}```')+"<DL>通过解构的方法，直接将commit传入，可以直接调用。</DL><BT4>1.4.1 提交actions的方法</BT4><DL>提交actions的方法有两种，一种是直接提交:<eng>this.$store.dispatch( 'setOne' ,20000)</eng>。同样，actions也有对象的提交方式：</DL>"+n('```\nstore.dispatch({\n  type: "setTwo",\n    n: 10\n  }\n}```')+"<BT2>2. 注意点</BT2>\n            <BT3>2.1 辅助函数</BT3>\n            <DL>辅助函数的作用就是简化操作，比如要获取获取多个state状态，需要在计算属性中声明多个函数，这样就显得冗余。此时可以使用<eng>mapState</eng>辅助函数。</DL><BT4>2.1.1 mapState辅助函数</BT4>"+n('```\nimport { mapState } from "vuex";\ncomputed: {\n  ...mapState({\n    count: state => state.num,\n    a: state => state.a\n  })\n}```')+"<BT4>2.1.2 mapGeters辅助函数</BT4>"+n('```\nimport { mapGetters } from "vuex";\ncomputed: {\n  ...mapGetters(["getOne"]),\n}```')+"<BT4>2.1.3 mapMutitions辅助函数</BT4>"+n('```\nimport { mapMutitions } from "vuex";\nmethods: {\n  ...mapMutations([\n    "SET_NUM"\n  ])\n}```')+"<DL>将 <eng>this.SET_NUM()</eng> 映射为<eng>this.$store.commit( 'SET_NUM' )</eng>,可以方便的提交<eng>mutitions</eng>。</DL><BT4>2.1.4 mapActions辅助函数</BT4>"+n('```\nimport { mapActions } from "vuex";\nmethods: {\n  ...mapActions(["setNum"])\n}```')+"<DL>将 <eng>this.setNum()</eng> 映射为<eng>this.$store.dispatch( 'setNum' )</eng>,可以方便的提交<eng>mutitions</eng>。</DL><BT3>2.2 mutications和actions</BT3>\n            <DL>actions提交的是mutitions，不是直接改变的状态，这样看来似乎是多此一举，实则是因为mutications不能提交异步过程（提交以后实际上可以正常执行，但是在vuetools上边捕捉不到），而在actions可以提交任意的一部过程。</DL>\n            <BT3>2.3 Vue.use(Vuex)</BT3><BT3>2.4 Vuex的生命周期</BT3><DL><eng>Vuex</eng>是存在生命周期的，当页面刷新的时候，Vue会重新实例化，此时<eng>Vuex</eng>保存的数据会全部丢失。此时如果二级页面依赖Vuex的数据，就可能造成数据丢失的情况。常见的解决方法：</DL>\n            <BT4>2.4.1 切换页面时使用query传参</BT4>\n            <DL>使用query传参的时候数据会在地址栏显示出来，此时本页面可以看作事与上一个页面切断了联系，刷新的时候数据直接从导航栏获取。</DL>\n            <BT4>2.4.2 locastorage、sessionstorage</BT4>\n            <DL>两个方法刷新页面的时候数据都不会丢失，sessionstorage会在关闭浏览器的时候消失，sessionstorage只要不手动清除，会一直保存。</DL>"}}Object.defineProperty(t,"__esModule",{value:!0}),e.d(t,"func",function(){return s})}});
//# sourceMappingURL=1.f2629fd6c515fb0d6ec1.js.map