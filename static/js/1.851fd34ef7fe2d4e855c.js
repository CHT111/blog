webpackJsonp([1],{Svoh:function(n,e,a){"use strict";function s(n){return{title:"this",time:"2019-1-6 10:51",structure:{"1. 概述":0,"2. this指向问题详解":{"2.1 默认指向window（全局）":0,"2.2 隐式绑定":0,"2.3 显示绑定改变this指向":0,"2.4 new绑定":1},"3. 注意":{"3.1 箭头函数":0,"3.2 bind":0}},comtent:"<BT2>1. 概述</BT2>\n            <DL>this 是JavaScript中的难点之一，深入了解this的指向问题对我们的技能提升有很大的帮助。  \n            this是在函数体内自动生成的一个对象，只能在函数体内使用。\n            </DL>\n            <BT2>2. this指向问题详解</BT2>\n            <BT3>2.1 默认指向window（全局）</BT3>\n            <DL>this的默认指向为window（global）</DL>\n            "+n("```\nvar name='CHT'\nfunction a(){\n    console.log(this.name)\n}\na()  //CHT\n            ```")+"<DL>执行上面的函数，我们可以看到打印出的name是全局变量name的值（声明全局变量的时候回自动把这个变量挂在全局window或者global上。）。如果未找到这个属性，将会返回<eng>undefined</eng>。</DL>\n            <BT3>2.2 隐式绑定</BT3>"+n("```\nvar obj = {\n    name: 'CHT',\n    sayName:sayName\n}\nfunction sayName(){\n    console.log(this.name)\n}\nobj.sayName()   //CHT\n    ```")+"<DL>当函数作为对象属性调用的时候，this会指向当前调用对象。但是当应用这种绑定的时候，很容易出现绑定丢失现象:</DL>"+n("```\nvar obj = {\n    Name: 'CHT',\n    sayName:sayName\n}\nfunction sayName(){\n    console.log(this,this.Name)\n}\nvar Say=obj.sayName   //将obj内的属性保存到外部变量！\nSay()                 //window,undefined\n```")+'<DL>从上面代码可以看到，当我们把内部属性值保存在外部的时候，this指向"丢失"了，指向了全局。此时，也说明了this的一个重要的特点：this指向取决于它的运行时而不是调用时。（箭头函数将这一重要的特性改变！）</DL>\n            <BT3>2.3 显示绑定改变this指向</BT3>\n            '+n("```\nvar obj={\n    name:'CHT'\n}\nfunction sayName(a){\n    console.log(a+','+this.name)\n}\nsayName.call(obj,'hello')   //hello,CHT\nsayName.apply(obj,['bye'])  //bye,CHT\n            ```")+'<DL>通过call/apply可以改变this的指向问题，<eng>sayName</eng>函数本是一个普通调用，指向的应该是<eng>window</eng>，但是通过<eng>call/apply</eng>,将<eng>this</eng>指向为传入的第一个参数。<eng>call和apply</eng>的作用都是改变this指向，唯一的区别就是传参列表不同。</DL><DL><eng>call</eng>可以接受多个参数，从第二个参数开始就是传入函数执行所需要的参数。如上边的函数调用，"hello"就是作为函数<eng>sayName</eng>的第一个参数传入 。如果有多个参数的话，以此类推。<eng>apply</eng>接受两个参数，第二个从参数是一个数组，作为函数调用所需要的参数传入。</DL>\n            <BT3>2.4 new绑定</BT3>\n            '+n("```\nfunction Car(speed,color,name){\n    this.name=name;\n    this.speed=speed;\n    this.color=color;\n}\nvar car;\nCar(100,'pink','mini')\ncar=new Car(200,'red','PP')\nconsole.log(car) //Car {name: \"PP\", speed: 200, color: \"red\"}\nconsole.log(color,speed,name) //pink 100 mini\n                        ```")+"<DL>正如之前所说,函数在正常执行的时候<eng>this</eng>指向的是<eng>window</eng>，此时生成了三个全局变量。当把函数看做构造函数，用<eng>new</eng>来调用时，可以看做是发生了以下步骤：</DL>\n            <wk>\n                <list>1.在函数顶层声明this变量：var this={}</list>\n                <list>2.执行函数体内的this属性赋值</list>\n                <list>3.返回this对象</list>\n            </wk>\n            <DL>如下所示：</DL>\n           "+n("```\nfunction Car(speed,color,name){\n    var this={};\n    this.name=name;\n    this.speed=speed;\n    this.color=color;\n    return this;\n}\n            ```")+"<BT2>3. 注意</BT2>\n            <BT3>3.1 箭头函数</BT3>\n            <DL>ES6新增的箭头函数,使得this的指向变得更加确定：</DL>"+n("```\nvar sayName=()=>{\n    console.log(this,this.Name)\n}\nvar obj={\n    Name:'CHT',\n    sayName:sayName\n}\nvar Name='XIAOMING';\nvar Say=obj.sayName;\nobj.sayName();  //window\nSay();          //window\nsayName()       //window\nsayName.call(obj)   //window\n            ```")+"<DL>出现这种情况的原因是箭头函数将this绑定为函数定义时所在的此法作用域，而不是执行的时候确定this指向。看下面的代码：</DL>"+n("```\nvar age=20\nvar obj={\n    age:18,\n    sayAge:function(){\n        setTimeout(function(){\n            console.log(this.age)\n        },10)\n    }\n}\nobj.sayAge();  //20\n\n//解决办法：\nvar obj={\n    age:18,\n    sayAge:function(){\n        var _this=this;\n        setTimeout(function(){\n            console.log(_this.age)\n        },10)\n    }\n}\nobj.sayAge();  //18\n// 使用箭头函数\nvar obj={\n    age:18,\n    sayAge:function(){\n        var _this=this;\n        setTimeout(\n            ()=>{console.log(_this.age)\n        },10)\n    }\n}\nobj.sayAge();  //18\n            ```")+"<DL>可以看到，箭头函数的<eng>this</eng>指向是定义时所在的此法作用域，而不是取决于执行环境。使得代码逻辑更加简单。</DL>\n            <BT3>3.2 bind</BT3>\n            <DL><eng>bind</eng>与<eng>call/apply</eng>的作用相同,也是改变<eng>this</eng>指向。不同的是<eng>call/apply</eng>是在执行的时候绑定，<eng>bind</eng>则是返回一个新的函数：</DL>"+n("```\nfunction say(){\n    console.log(this.Name)\n}\nvar obj={\n    Name:'CHT'\n}\nvar Say=say.bind(obj);\nSay()  //CHT\n            ```")+"<DL><eng>bind</eng>还有另外一个作用,预置函数参数：</DL>"+n("```\nfunction say(age){\n    console.log({name:this.Name,age:age},arguments)\n}\nvar obj={\n    Name:'CHT'\n}\nvar Say=say.bind(obj,18);\nSay(1)  //{name: \"CHT\", age: 18}    [18, 1,]\n            ```")+"<DL>bind从第二个参数开始，就是给函数传的参数，而函数执行的时候传入的参数会依次顺延。</DL>"}}Object.defineProperty(e,"__esModule",{value:!0}),a.d(e,"func",function(){return s})}});