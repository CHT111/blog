{"version":3,"sources":["webpack:///./src/data/bibao.js"],"names":["func","marked","title","time","structure","1. 概述","2. 闭包的作用","2.1 外部环境访问内部变量","2.2 保持闭包所引用的变量一直保存在内存中不被回收","3. 使用闭包所注意的点","3.1 this的指向问题","comtent","Object","defineProperty","__webpack_exports__","value","__webpack_require__","d"],"mappings":"oDAAA,SAASA,EAAKC,GACV,OACIC,MAAO,KACPC,KAAM,mBACNC,WACIC,QAAS,EACTC,YACIC,iBAAkB,EAClBC,6BAA6B,GAEjCC,gBACIC,gBAAgB,IAIxBC,QACI,2MAGEV,EAAO,kHAHT,oFAYAA,EAAO,+BAZP,+NAmBAA,EAAO,sIAnBP,kEA8BAA,EAAO,4HA9BP,6OA2CAA,EAAO,oQA3CP,sRAqEAA,EAAO,ySArEP,iDAyFAA,EAAO,8CAzFP,uBA6FAA,EAAO,yDA7FP,qFAhBZW,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IAAAC,EAAAC,EAAAH,EAAA,yBAAAd","file":"static/js/1.0bcb7b8795519d2309ec.js","sourcesContent":["function func(marked) {\r\n    return {\r\n        title: '闭包',\r\n        time: '2018-12-28 23:24',\r\n        structure: {\r\n            '1. 概述': 0,\r\n            '2. 闭包的作用': {\r\n                '2.1 外部环境访问内部变量': 0,\r\n                '2.2 保持闭包所引用的变量一直保存在内存中不被回收':1\r\n            },\r\n            '3. 使用闭包所注意的点':{\r\n                '3.1 this的指向问题':0\r\n            }\r\n\r\n        },\r\n        comtent:\r\n            `<BT2>1. 概述</BT2>\r\n        <DL>前端学习较难的一个知识点就是闭包。闭包用的好能完成很多特殊的功能，一旦用的不好，将会造成内存泄漏，降低程序的性能。</DL>\r\n        <DL>变量都有自己的作用域，比如函数内的变量只能在函数体内访问，在函数体外边是访问不到的。那有没有一种办法能够让外部环境读取到函数内部的变量呢？答案是有的。那就是通过函数内部的子函数：</DL>`\r\n            + marked('```' + `\r\nfunction a(){  \r\n    var i=2  \r\n    return function b(){\r\n        console.log(i)\r\n    }  \r\n}\r\n        `+ '```') + `\r\n        <DL>从上边代码我们可以看出，函数b可以访问到函数a的内部变量i，然后可以把函数b返回，这样的话函数a执行以后就对外暴露了函数b：</DL>`+\r\n            marked('```' + `\r\nvar B=a()\r\n        `+ '```') + `\r\n        <DL>这样的话B就得到了函数b，此时再执行<eng>B()</eng>就能访问到函数a的内部变量i了，这个时候我们就说这是生成了一个闭包。因此，对闭包的定义是:<eng>能访问函数内部变量的函数。</eng>所以闭包指的是一个函数。</DL>\r\n        <BT2>2. 闭包的作用</BT2>\r\n        <BT3>2.1 外部环境访问内部变量</BT3>\r\n        <DL>以下代码：</DL>`+\r\n            marked('```' + `\r\nfunction a(){  \r\n    var i=2;\r\n    return function b(){\r\n        console.log(i)\r\n    }\r\n}\r\nvar B=a();\r\nB();  //2\r\n        `+ '```') + `\r\n        <DL>执行以上代码，会返回2，说明通过闭包，我们可以访问到函数a内部的变量i。再看以下的代码：</DL>`+\r\n            marked('```' + `\r\nfunction a(){  \r\n    var i=2;\r\n    B = function b(){\r\n        console.log(i)\r\n    }\r\n}\r\na()\r\nB();  //2\r\n        `+ '```') + `\r\n        <DL>以上代码同样会打印2。因为当你在函数a内不显示的声明B时，如果当前作用域链中没有声明变量B，javascript引擎会沿着作用域链往上查找，如果没有的话会自动创建一个全局变量B<zs>(非严格模式下，严格模式下会抛出异常。详请参见《你不知道的JavaScript(上卷)》)</zs>。</DL>\r\n        <BT3>2.2 保持闭包所引用的变量一直保存在内存中不被回收</BT3>\r\n        <DL>看以下代码：</DL>`+\r\n            marked('```' + `\r\n//不使用闭包\r\nfunction a(){  \r\n    var i=2;\r\n    console.log(i++)\r\n}\r\na()  //2\r\na()  //2\r\na()  //2\r\n\r\n//使用闭包\r\nfunction b (){\r\n    var i = 2;\r\n    return function B(){\r\n        console.log(++i)\r\n    }\r\n}\r\nvar B=b()\r\nB()  //3\r\nB()  //4\r\nB()  //5\r\n        `+ '```') + `\r\n        <DL>会发现，没有使用闭包的函数a执行的时候变量i每次都被重置为2，而使用了闭包的函数b将内层函数B保存出来以后，每次执行内层函数B的时候都会读取到函数b的变量i，并且变量i一直保存在内存中，没有被垃圾回收机制回收。</DL>\r\n        <BT2>3. 使用闭包所注意的点</BT2>\r\n        <BT3>3.1 this的指向问题</BT3>\r\n        <DL>因为闭包 可以将函数内部的函数保存出来，等到需要的时候在执行，所以就造成了<eng>this</eng>指向的问题，看下边的代码:</DL>`+\r\n            marked('```' + `\r\nvar a=1;\r\nvar obj1={\r\n        a:0,\r\n        sayA:function(){\r\n            console.log(this.a)\r\n        }\r\n    }\r\nvar obj2={\r\n    a:0,\r\n    sayA:function(){\r\n        return function(){\r\n            console.log(this.a)\r\n        }\r\n    }\r\n}\r\nobj1.sayA()  //0\r\nobj2.sayA()()  //1\r\n        `+ '```') + `\r\n        <DL>对于obj2的结果可能不是很好理解，可以把它拆分来看：</DL>`+\r\n            marked('```' + `\r\nvar OBJ2=obj2.sayA()\r\nOBJ2()\r\n    `+ '```') + `<DL>此时OBJ2的值就是：</DL>` +\r\n            marked('```' + `\r\nfunction(){\r\n    console.log(this.a)\r\n}\r\n    `+ '```') + `\r\n        <DL>在全局环境下执行一个函数，this是指向window，所以最终打印的会是1。<zs>（详请参见this的指向问题）</zs></DL>`\r\n\r\n\r\n\r\n\r\n\r\n\r\n        //段落\r\n        // + `<DL></DL>`\r\n        //引用的代码\r\n        // + `<eng></eng>`\r\n        //注释\r\n        // + `<zs></zs>`\r\n        // + `<BT1></BT1>`\r\n        // + `<BT2></BT2>`\r\n        // + `<BT3></BT3>`\r\n        // + `<BT4></BT4>`\r\n    };\r\n}\r\nexport { func }\n\n\n// WEBPACK FOOTER //\n// ./src/data/bibao.js"],"sourceRoot":""}