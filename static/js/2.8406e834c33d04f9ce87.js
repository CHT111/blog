webpackJsonp([2],{jP0Z:function(n,o,i){"use strict";function a(n){return{title:"闭包",time:"2018-12-28 23:24",structure:{"1. 概述":0,"2. 闭包的作用":{"2.1 外部环境访问内部变量":0,"2.2 保持闭包所引用的变量一直保存在内存中不被回收":1},"3. 使用闭包所注意的点":{"3.1 this的指向问题":0}},comtent:"<BT2>1. 概述</BT2>\n        <DL>前端学习较难的一个知识点就是闭包。闭包用的好能完成很多特殊的功能，一旦用的不好，将会造成内存泄漏，降低程序的性能。</DL>\n        <DL>变量都有自己的作用域 ，比如函数内的变量只能在函数体内访问，在函数体外边是访问不到的。那有没有一种办法能够让外部环境读取到函数内部的变量呢？答案是有的。那就是通过函数内部的子函数：</DL>"+n("```\nfunction a(){  \n    var i=2  \n    return function b(){\n        console.log(i)\n    }  \n}\n        ```")+"\n        <DL>从上边代码我们可以看出，函数b可以访问到函数a的内部变量i，然后可以把函数b返回，这样的话函数a执行以后就对外暴露了函数b：</DL>"+n("```\nvar B=a()\n        ```")+"\n        <DL>这样的话B就得到了函数b，此时再执行<eng>B()</eng>就能访问到函数a的内部变量i了，这个时候我们就说这是生成了一个闭包。因此，对闭包的定义是:<eng>能访问函数内部变量的函数,并且函数的执行在定义时所在的词法作用域之外。</eng>所以闭包指的是一个函数。</DL>\n        <BT2>2. 闭包的作用</BT2>\n        <BT3>2.1 外部环境访问内部变量</BT3>\n        <DL>以下代码：</DL>"+n("```\nfunction a(){  \n    var i=2;\n    return function b(){\n        console.log(i)\n    }\n}\nvar B=a();\nB();  //2\n        ```")+"\n        <DL>执行以上代码，会返回2，说明通过闭包，我们可以访问到函数a内部的变量i。再看以下的代码：</DL>"+n("```\nfunction a(){  \n    var i=2;\n    B = function b(){\n        console.log(i)\n    }\n}\na()\nB();  //2\n        ```")+"\n        <DL>以上代码同样会打印2。因为当你在函数a内不显示的声明B时，如果当前作用域链中没有声明变量B，javascript引擎会沿着作用域链往上查找，如果没有的话会自动创建一个全局变量B<zs>(非严格模式下，严格模式下会抛出异常。详请参见《你不知道的JavaScript(上卷)》)</zs>。</DL>\n        <BT3>2.2 保持闭包所引用的变量一直保存在内存中不被回收</BT3>\n        <DL>看以下代码：</DL>"+n("```\n//不使用闭包\nfunction a(){  \n    var i=2;\n    console.log(i++)\n}\na()  //2\na()  //2\na()  //2\n\n//使用闭包\nfunction b (){\n    var i = 2;\n    return function B(){\n        console.log(++i)\n    }\n}\nvar B=b()\nB()  //3\nB()  //4\nB()  //5\n        ```")+"\n        <DL>会发现，没有使用闭包的函数a执行的时候变量i每次都被重置为2，而使用了闭包的函数b将内层函数B保存出来以后，每次执行内层函数B的时候都会读取到函数b的变量i，并且变量i一直保存在内存中，没有被垃圾回收机制回收。</DL>\n        <BT2>3. 使用闭包所注意的点</BT2>\n        <BT3>3.1 this的指向问题</BT3>\n        <DL>因为闭包 可以将函数内部的函数保存出来，等到需要的时候在执行，所以就造成了<eng>this</eng>指向的问题，看下边的代码:</DL>"+n("```\nvar a=1;\nvar obj1={\n        a:0,\n        sayA:function(){\n            console.log(this.a)\n        }\n    }\nvar obj2={\n    a:0,\n    sayA:function(){\n        return function(){\n            console.log(this.a)\n        }\n    }\n}\nobj1.sayA()  //0\nobj2.sayA()()  //1\n        ```")+"\n        <DL>对于obj2的结果可能不是很好理解，可以把它拆分来看：</DL>"+n("```\nvar OBJ2=obj2.sayA()\nOBJ2()\n    ```")+"<DL>此时OBJ2的值就是：</DL>"+n("```\nfunction(){\n    console.log(this.a)\n}\n    ```")+"\n        <DL>在全局环境下执行一个函数，this是指向window，所以最终打印的会是1。<zs>（详请参见this的指向问题）</zs></DL>"}}Object.defineProperty(o,"__esModule",{value:!0}),i.d(o,"func",function(){return a})}});