{"version":3,"sources":["webpack:///./src/data/vuex.js"],"names":["func","marked","title","time","structure","1. 概述","1.1 state","1.1.1 获取状态","1.2 getters","1.3 mutations","1.3.1 对象的提交方式","1.4 actions","1.4.1 提交actions的方法","2. 注意点","2.1 辅助函数","2.1.1 mapState辅助函数","2.1.2 mapGeters辅助函数","2.1.3 mapMutations辅助函数","2.1.4 mapActions辅助函数","2.2 mutications和actions","2.3 Vue.use(Vuex)","2.4 Vuex的生命周期","2.4.1 切换页面时使用query传参","2.4.2 locastorage、sessionstorage","comtent","Object","defineProperty","__webpack_exports__","value","__webpack_require__","d"],"mappings":"oDAAA,SAASA,EAAKC,GACV,OACIC,MAAO,SACPC,KAAM,aACNC,WACIC,SACIC,aACIC,aAAc,GAElBC,cAAe,EACfC,iBACIC,gBAAiB,GAErBC,eACIC,qBAAsB,IAG9BC,UACIC,YACIC,qBAAsB,EACtBC,sBAAuB,EACvBC,yBAA0B,EAC1BC,uBAAwB,GAE5BC,0BAA2B,EAC3BC,oBAAqB,EACrBC,iBACIC,uBAAwB,EACxBC,mCAAoC,KAMhDC,QACI,yKAIEvB,EAAO,2EAJT,kPAWGA,EAAO,+EAXV,mQAgBGA,EAAO,yDAhBV,sDAmBAA,EAAO,6FAnBP,iPAwBAA,EAAO,2EAxBP,wTAgCAA,EAAO,wFAhCP,uHAmCAA,EAAO,iFAnCP,2KAsCAA,EAAO,kEAtCP,6LA0CkCA,EAAO,4IA1CzC,iCA4CAA,EAAO,4FA5CP,oCA8CAA,EAAO,yGA9CP,iJAgDAA,EAAO,0FAhDP,2vBAnCZwB,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IAAAC,EAAAC,EAAAH,EAAA,yBAAA3B","file":"static/js/0.708f6d102d1c2e479ce0.js","sourcesContent":["function func(marked) {\r\n    return {\r\n        title: '关于vuex',\r\n        time: '2018-12-25',\r\n        structure: {\r\n            '1. 概述': {\r\n                '1.1 state': {\r\n                    '1.1.1 获取状态': 1\r\n                },\r\n                '1.2 getters': 0,\r\n                '1.3 mutations': {\r\n                    '1.3.1 对象的提交方式': 1\r\n                },\r\n                '1.4 actions': {\r\n                    '1.4.1 提交actions的方法': 2\r\n                }\r\n            },\r\n            '2. 注意点': {\r\n                '2.1 辅助函数': {\r\n                    '2.1.1 mapState辅助函数': 0,\r\n                    '2.1.2 mapGeters辅助函数': 0,\r\n                    '2.1.3 mapMutations辅助函数': 0,\r\n                    '2.1.4 mapActions辅助函数': 1\r\n                },\r\n                '2.2 mutications和actions': 0,\r\n                '2.3 Vue.use(Vuex)': 0,\r\n                '2.4 Vuex的生命周期': {\r\n                    '2.4.1 切换页面时使用query传参': 0,\r\n                    '2.4.2 locastorage、sessionstorage': 0\r\n                },\r\n\r\n            }\r\n\r\n        },\r\n        comtent:\r\n            `<BT2>1. 概述</BT2>\r\n        <DL>vuex是vue的状态管理工具，将所有的数据集中在一起管理,它分为以下四个部分:</DL>\r\n        <BT3>1.1 state</BT3>\r\n        <DL>state是vuex的状态集合，所有的状态都存在这个集合内,他是一个对象集合，如下：</DL>`\r\n            + marked('```\\nstate:{\\n  num:0,\\n  one:\"this is one\",\\n  two:\"this is two\"\\n}```')\r\n            +\r\n            `\r\n            <DL>以上代码就是一个简单的状态集合，管理着全局的num、one、two. 所有关于这三个变量的获取、修改，都要通过vuex来改变。</DL>\r\n            <BT4>1.1.1 获取状态</BT4>\r\n            <DL>Vue可以将vuex通过根组件注入到每一个子组件中，并且在子组件中可以直接使用<eng>this.$store.state</eng>来访问状态：</DL>\r\n      \r\n            `+ marked('```\\ncomputed: {\\n  count () {\\n    return this.$store.state.two\\n  }\\n}```') +\r\n            `\r\n            <DL>通过计算属性绑定以后，当<eng>two</eng>发生变化时，会及时反馈在count上边，实现动态更新。</DL>\r\n            <BT3>1.2 getters</BT3>\r\n            <DL>getters一般用于获取state的派生状态，比如存一个数字num，获取的时候要获取num²，这样在每个组件获取后再分别处理会比较麻烦，此时可以用<eng>getters</eng>处理完毕以后直接获取num²：</DL>\r\n            `+ marked('```\\ngetters: {\\n  getOne: (state) => state.one\\n}```') +\r\n            `<DL>在组件中使用的方法类似<eng>state</eng>:</DL>\r\n            `+\r\n            marked('```\\ncomputed: {\\n  count () {\\n    return this.$store.getters.getOne + \"dede\"\\n  }\\n}```')\r\n            + `\r\n            <DL>此时count也会跟随state的状态变化而变化，实现动态改变。</DL>\r\n            <BT3>1.3 mutations</BT3>\r\n            <DL>改变state状态的唯一方法就是提交mutations（vue官网）。即不能直接调用mutations的函数，应该通过<eng>this.$store.commit( 'SET_ONE' ,1000)</eng>。一个mutions的结构如下：</DL>`+\r\n            marked('```\\nmutations: {\\n  SET_ONE(state, n) {\\n    state.one = n;\\n  }\\n}```') +\r\n            `<DL>mutations接收的第一个参数就是<eng>state</eng>。</DL>\r\n            <BT4>1.3.1 对象的提交方式</BT4>\r\n            <DL>mutations的第二种提交方法:对象方式：<eng>this.$store.commit({ type : 'SET_ONE' , n : 121222121 })</eng>。\r\n            </DL>\r\n            <BT3>1.4 actions</BT3>\r\n            <DL>actions提交的的是mutations。如下：</DL>\r\n            `+\r\n            marked('```\\nactions: {\\n  setTwo(context, n) {\\n    context.commit(\"SET_TWO\", n)\\n  }\\n}```')\r\n            +\r\n            `<DL>context是一个与store有相同的方法和属性的对象，可以直接调用<eng>context.commit( 'SET_ONE' )</eng>来提交mutations。在实践中，我们可以利用参数解构来简化代码：</DL>` +\r\n            marked('```\\nactions: {\\n  setOne({commit}, n) {\\n    commit(\"SET_ONE\", n)\\n  }\\n}```') +\r\n            `<DL>通过解构的方法，直接将commit传入，可以直接调用。</DL>` + `<BT4>1.4.1 提交actions的方法</BT4>`\r\n            + `<DL>提交actions的方法有两种，一种是直接提交:<eng>this.$store.dispatch( 'setOne' ,20000)</eng>。同样，actions也有对象的提交方式：</DL>` +\r\n            marked('```\\nstore.dispatch({\\n  type: \"setTwo\",\\n    n: 10\\n  }\\n}```') +\r\n            `<BT2>2. 注意点</BT2>\r\n            <BT3>2.1 辅助函数</BT3>\r\n            <DL>辅助函数的作用就是简化操作，比如要获取获取多个state状态，需要在计算属性中声明多个函数，这样就显得冗余。此时可以使用<eng>mapState</eng>辅助函数。</DL>`+\r\n            `<BT4>2.1.1 mapState辅助函数</BT4>` + marked('```\\nimport { mapState } from \"vuex\";\\ncomputed: {\\n  ...mapState({\\n    count: state => state.num,\\n    a: state => state.a\\n  })\\n}```') +\r\n            `<BT4>2.1.2 mapGeters辅助函数</BT4>` +\r\n            marked('```\\nimport { mapGetters } from \"vuex\";\\ncomputed: {\\n  ...mapGetters([\"getOne\"]),\\n}```') +\r\n            `<BT4>2.1.3 mapMutations辅助函数</BT4>` +\r\n            marked('```\\nimport { mapMutations } from \"vuex\";\\nmethods: {\\n  ...mapMutations([\\n    \"SET_NUM\"\\n  ])\\n}```') + `<DL>将 <eng>this.SET_NUM()</eng> 映射为<eng>this.$store.commit( 'SET_NUM' )</eng>,可以方便的提交<eng>mutations</eng>。</DL>` +\r\n            `<BT4>2.1.4 mapActions辅助函数</BT4>` +\r\n            marked('```\\nimport { mapActions } from \"vuex\";\\nmethods: {\\n  ...mapActions([\"setNum\"])\\n}```') + `<DL>将 <eng>this.setNum()</eng> 映射为<eng>this.$store.dispatch( 'setNum' )</eng>,可以方便的提交<eng>mutations</eng>。</DL>` +\r\n            `<BT3>2.2 mutications和actions</BT3>\r\n            <DL>actions提交的是mutations，不是直接改变的状态，这样看来似乎是多此一举，实则是因为mutications不能提交异步过程（提交以后实际上可以正常执行，但是在vuetools上边捕捉不到），而在actions可以提交任意的一部过程。</DL>\r\n            ` + `<BT3>2.3 Vue.use(Vuex)</BT3>`\r\n            + `<BT3>2.4 Vuex的生命周期</BT3>` +\r\n            `<DL><eng>Vuex</eng>是存在生命周期的，当页面刷新的时候，Vue会重新实例化，此时<eng>Vuex</eng>保存的数据会全部丢失。此时如果二级页面依赖Vuex的数据，就可能造成数据丢失的情况。常见的解决方法：</DL>\r\n            <BT4>2.4.1 切换页面时使用query传参</BT4>\r\n            <DL>使用query传参的时候数据会在地址栏显示出来，此时本页面可以看作事与上一个页面切断了联系，刷新的时候数据直接从导航栏获取。</DL>\r\n            <BT4>2.4.2 locastorage、sessionstorage</BT4>\r\n            <DL>两个方法刷新页面的时候数据都不会丢失，sessionstorage会在关闭浏览器的时候消失，sessionstorage只要不手动清除，会一直保存。</DL>`\r\n\r\n\r\n\r\n        // + `<DL></DL>`\r\n        // + `<eng></eng>`\r\n        // + `<BT1></BT1>`\r\n        // + `<BT2></BT2>`\r\n        // + `<BT3></BT3>`\r\n        // + `<BT4></BT4>`\r\n    };\r\n}\r\nexport { func }\n\n\n// WEBPACK FOOTER //\n// ./src/data/vuex.js"],"sourceRoot":""}